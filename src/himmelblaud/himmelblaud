#!/usr/bin/python3
import socket
import os
import argparse
import logging
from systemd.journal import JournalHandler
from configparser import ConfigParser
from pathlib import Path
import json
from enum import Enum
import random
from msal import PublicClientApplication

DEFAULT_CONFIG_PATH = '/etc/himmelblau/himmelblau.conf'
DEFAULT_CONFIG_DIR = '/etc/himmelblau/himmelblau.d'
DEFAULT_SOCK_PATH = '/var/run/himmelblaud/socket'

class ConfigError(Exception):
    pass

class AzureError(Enum):
    INVALID_CRED = 0xC3CE
    REQUIRES_MFA = 0xC39C
    INVALID_USER = 0xC372
    NO_CONSENT   = 0xFDE9
    NO_SECRET    = 0x6AD09A

class Himmelblaud:
    def __init__(self, configfile, debuglevel):
        self.configfile = configfile
        self.logger = logging.getLogger(__name__)
        # Send the logs to systemd
        journald_handler = JournalHandler()
        journald_handler.setFormatter(logging.Formatter(
            '[%(levelname)s] %(message)s'
        ))
        self.logger.addHandler(journald_handler)
        self.logger.setLevel(debuglevel)
        self.logger.info('Loading configuration from %s' % self.configfile)
        self.config = ConfigParser()
        self.config['DEFAULT'] = { 'socket_path': DEFAULT_SOCK_PATH }
        if os.path.exists(self.configfile):
            try:
                self.config.read(self.configfile)
            except Exception as e:
                self.logger.warning(str(e))
        cdir = Path(DEFAULT_CONFIG_DIR)
        if cdir.is_dir():
            for configfile in sorted([x for x in cdir.iterdir() if x.is_file()]):
                self.logger.info('Loading configuration from %s' % configfile)
                try:
                    self.config.read(configfile)
                except Exception as e:
                    self.logger.warning(str(e))
        if not self.config.has_section('global'):
            self.config.add_section('global')
        self.connect_application()

    def handle_msg_recv(self, conn):
        msg = b''
        while True:
            try:
                data = conn.recv(1024)
            except Exception as e:
                self.logger.error('Failed receiving data from socket')
                return
            if len(data) == 0:
                self.logger.debug('No more bytes received, we have completed')
                break
            elif len(data) == 1024:
                msg += data
                self.logger.debug('Filled 1024 bytes, continuing')
                continue
            else:
                msg += data
                self.logger.debug('Filled %d bytes, complete' % len(data))
                break
        return json.loads(msg)

    def connect_application(self, uname=None):
        # Get the tenant and app ids from the config
        if not self.config.has_option('global', 'tenant_id'):
            self.logger.error('The tenant id was not set in the configuration')
            raise ConfigError()
        self.tenant_id = self.config.get('global', 'tenant_id')
        if not self.config.has_option('global', 'app_id'):
            self.logger.error('The app id was not set in the configuration')
            raise ConfigError()
        self.app_id = self.config.get('global', 'app_id')

        # TODO: Check for domain specific tenant and app ids
        if uname != None:
            pass

        # Create the app for connecting to Azure AD
        self.authority_url = 'https://login.microsoftonline.com/%s' % self.tenant_id
        self.app = PublicClientApplication(self.app_id, authority=self.authority_url)

    def find_account(self, uname):
        # Fetch an account from the list of cached accounts
        accounts = self.app.get_accounts()
        for account in accounts:
            if account['username'] == uname:
                return account
        return None

    def handle_nss_account_by_name(self, uname):
        account = self.find_account(uname)
        if account != None:
            random.seed(account['home_account_id'])
            uid = random.randint(10000, 2**32) # TODO: Config opt for uid range
            return {
                'name': uname,
                'uid': uid,
                'gid': uid, # TODO: How do I find group memberships?
                'gecos': uname, # TODO: We can get this from the token
                'homedir': '/home/%s' % uname,
                'shell': '/bin/bash'
            }
        else:
            return None

    def handle_nss_accounts(self):
        result = []
        accounts = self.app.get_accounts()
        for account in accounts:
            random.seed(account['home_account_id'])
            uid = random.randint(10000, 2**32) # TODO: Config opt for uid range
            result.append({
                'name': account['username'],
                'uid': uid,
                'gid': uid, # TODO: How do I find group memberships?
                'gecos': account['username'], # TODO: We can get this from the token
                'homedir': '/home/%s' % account['username'],
                'shell': '/bin/bash'
            })
        return result

    def handle_authenticate(self, uname, passwd):
        # Authenticate to Azure AD
        token = self.app.acquire_token_by_username_password(uname, passwd, [])
        if 'access_token' in token.keys():
            self.logger.info('Authentication successful for user "%s"' % uname)
        elif 'error_codes' in token.keys() and AzureError.INVALID_USER in token['error_codes']:
            return None
        else:
            if 'error_codes' in token.keys():
                if AzureError.REQUIRES_MFA in token['error_codes']:
                    self.logger.info('Azure AD application requires MFA')
                    token = self.app.acquire_token_interactive([], login_hint=uname)
                    if 'access_token' in token.keys():
                        self.logger.info('Authentication successful for user "%s"' % uname)
                        return True
                if AzureError.NO_CONSENT in token['error_codes']:
                    url = '%s/adminconsent?client_id=%s' % (self.authority_url,
                                                            self.app_id)
                    self.logger.error('Azure AD application requires consent,' +
                                      ' either from tenant, or from user.' +
                                      'If you\'re a tenant\'s administrator,' +
                                      ' go to: ' + url)
                if AzureError.NO_SECRET in token['error_codes']:
                    url = 'https://learn.microsoft.com/en-us/azure/' + \
                        'active-directory/develop/scenario-desktop-app' + \
                        '-registration#redirect-uris'
                    self.logger.error('Azure AD application requires enabling' +
                                      ' \'Allow public client flows\'. ' + url)
            if 'error_description' in token.keys():
                self.logger.error(token['error_description'])
            return False
        return True

    def handle_msg_resp(self, msg):
        resp = {}
        if msg == 'NssGroup':
            resp['NssGroup'] = None # TODO: How do I find groups?
        elif msg == 'NssGroups':
            resp['NssGroups'] = [] # TODO: How do I find groups?
        elif msg == 'NssAccounts':
            resp['NssAccounts'] = self.handle_nss_accounts()
        elif type(msg) == dict and 'PamAuthenticate' in msg.keys():
            resp['PamStatus'] = self.handle_authenticate(*tuple(msg['PamAuthenticate']))
        elif type(msg) == dict and 'NssAccountByName' in msg.keys():
            resp['NssAccount'] = self.handle_nss_account_by_name(msg['NssAccountByName'])
        self.logger.debug(json.dumps(resp, indent=4))
        return json.dumps(resp).encode()

    def run(self):
        socket_path = self.config.get('global', 'socket_path')
        if os.path.exists(socket_path):
            os.remove(socket_path)
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.bind(socket_path)
        os.chmod(socket_path, 0o777)
        while True:
            sock.listen(1)
            conn, addr = sock.accept()
            msg = self.handle_msg_recv(conn)
            if type(msg) == dict and 'PamAuthenticate' in msg.keys():
                # Censor the password from the logs
                self.logger.debug(json.dumps({'PamAuthenticate': [
                    msg['PamAuthenticate'][0], 'X'*10
                ]}, indent=4))
            else:
                self.logger.debug(json.dumps(msg, indent=4))
            resp = self.handle_msg_resp(msg)
            conn.send(resp)
            conn.close()

desc = '''
Himmelblau is an interoperability suite for Microsoft Azure AD and Intune.
The Himmelblau daemon is the primary communication interface between Azure
and the Linux PAM and NSS services.
'''

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--configfile", "-s", help="Configuration file")
    parser.add_argument("--debuglevel", "-d",
                        help="Debug level. Default is WARNING.",
                        choices=['CRITICAL', 'ERROR', 'WARNING',
                                 'INFO', 'DEBUG', 'NOTSET'],
                        default='WARNING')
    parser.add_argument("--version", "-v", help="Display version number",
                        action="store_true")
    args = parser.parse_args()

    if args.version:
        print('himmelblau 0.1.0')
        exit(0)

    config = DEFAULT_CONFIG_PATH
    if args.configfile:
        config = args.configfile

    d = Himmelblaud(config, args.debuglevel)
    d.run()
